---
title: "建造者模式"
date: 2022-03-13
weight: 4
tags: [design pattern]
categories: []
author: "wangy325"
---

> 本文由Gemini AI生成。

## 建造模式

建造模式是一种创建型设计模式，它将一个复杂对象的构建与其表示分离。它允许你通过一步一步地构建对象来创建不同的表示。

<!--more-->

### 结构

建造模式包含以下角色：

- 抽象建造者（Builder）:  定义一个接口，指定构建复杂对象各个部分的步骤。
- 具体建造者（ConcreteBuilder）:  实现抽象建造者接口，具体实现构建复杂对象的步骤。
- 指挥者（Director）:  负责调用具体建造者的方法，构建复杂对象。
- 产品（Product）:  最终构建出来的复杂对象。

### UML简图

{{< mermaid >}}
classDiagram
  class Builder {
    << interface >>
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class ConcreteBuilder1 {
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class ConcreteBuilder2 {
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class Director {
    +construct()
  }
  class Product {
    +partA
    +partB
    +partC
  }

  Builder <|.. ConcreteBuilder1
  Builder <|.. ConcreteBuilder2
  Director --> Builder
  Director --> Product
  Product ..> ConcreteBuilder1
  Product ..> ConcreteBuilder2
{{< /mermaid >}}

```mermaid
classDiagram
  class Builder {
    <<interface>>
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class ConcreteBuilder1 {
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class ConcreteBuilder2 {
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class Director {
    +construct()
  }
  class Product {
    +partA
    +partB
    +partC
  }

  Builder <|.. ConcreteBuilder1
  Builder <|.. ConcreteBuilder2
  Director --> Builder
  Director --> Product
  Product ..> ConcreteBuilder1
  Product ..> ConcreteBuilder2
  ```

### 示例代码

#### 建造者

首先是建造者及其实现：

```java
// 抽象建造者
interface CarBuilder {
    void buildModel();
    void buildEngine();
    void buildColor();
    Car getCar();
}

// 具体建造者
class BenzCarBuilder implements CarBuilder {
    private Car car = new Car();

    @Override
    public void buildModel() {
        car.setModel("奔驰");
    }
    @Override
    public void buildEngine() {
        car.setEngine("V8发动机");
    }
    @Override
    public void buildColor() {
        car.setColor("黑色");
    }
    @Override
    public Car getCar() {
        return car;
    }
}

class BMWCarBuilder implements CarBuilder {
    private Car car = new Car();

    @Override
    public void buildModel() {
        car.setModel("宝马");
    }
    @Override
    public void buildEngine() {
        car.setEngine("直列六缸发动机");
    }
    @Override
    public void buildColor() {
        car.setColor("白色");
    }
    @Override
    public Car getCar() {
        return car;
    }
}
```

#### 产品

接下来是产品及其实现：

```java
// 产品
class Car {
    private String model;
    private String engine;
    private String color;

    public void setModel(String model) {
        this.model = model;
    }
    public void setEngine(String engine) {
        this.engine = engine;
    }
    public void setColor(String color) {
        this.color = color;
    }
    public String getModel() {
        return model;
    }
    public String getEngine() {
        return engine;
    }
    public String getColor() {
        return color;
    }
}
```

#### 指挥者

最后是指挥者：

```java
// 指挥者
class CarDirector {
    private CarBuilder builder;

    public CarDirector(CarBuilder builder) {
        this.builder = builder;
    }

    public Car constructCar() {
        builder.buildModel();
        builder.buildEngine();
        builder.buildColor();
        return builder.getCar();
    }
}
```

#### 测试代码

```java
// 使用建造模式
public class BuilderPatternDemo {
    public static void main(String[] args) {
        CarDirector director = new CarDirector(new BenzCarBuilder());
        Car benzCar = director.constructCar();
        System.out.println("奔驰汽车: " + benzCar.getModel() + "，" + benzCar.getEngine() + "，" + benzCar.getColor());

        director = new CarDirector(new BMWCarBuilder());
        Car bmwCar = director.constructCar();
        System.out.println("宝马汽车: " + bmwCar.getModel() + "，" + bmwCar.getEngine() + "，" + bmwCar.getColor());
    }
}
```

- 抽象建造者接口 `CarBuilder`： 定义了构建汽车的步骤，包括设置模型、发动机和颜色。
- 具体建造者 `BenzCarBuilder` 和 `BMWCarBuilder`：  分别实现了 `CarBuilder` 接口，并具体实现了构建奔驰汽车和宝马汽车的步骤。
- 产品 `Car`：  代表最终构建出来的汽车对象。
- 指挥者 `CarDirector`：  通过调用具体建造者的方法，来构建不同的汽车。

### 优点

- 将复杂对象的构建与表示分离。
- 可以更容易地创建不同的表示。
- 可以方便地扩展新类型。

### 建造模式和工厂模式的区别

> Generated by chatgpt.

建造者模式（Builder Pattern）和工厂模式（Factory Pattern，包括简单工厂模式、工厂方法模式和抽象工厂模式）都是用来创建对象的设计模式，但它们在意图、应用场景和实现方式上有所不同。

#### 建造者模式

建造者模式主要用于创建一种**复杂的对象**，其产品通常需要多个部分按特定的过程组合而成。这种模式允许用户通过指定复杂对象的类型和内容就可以构建它们，*用户不需要知道内部的具体构建细节*。

- 意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- 应用场景：当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；当构造过程必须允许被构造的对象有不同的表示时。
- 实现方式：通常由Director（指挥者）、Builder（建造者接口）、ConcreteBuilder（具体建造者）和Product（产品）组成。客户端创建Director对象，并用它所需要的Builder对象进行配置。Director决定如何以及何时让建造者产生部件，然后组合成产品返回。

#### 工厂模式

工厂模式主要用于创建对象，特别是在创建某个类的对象时不希望指定确切的类。工厂模式通过调用一个工厂方法而不是直接调用构造函数来创建对象（可能是指定的接口或抽象类的具体实现）。

- 意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
- 应用场景：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定创建的对象时；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪个帮助子类是代理者这一信息局部化时。
- 实现方式：可以分为三种：
  - 简单工厂模式：不属于GOF的23种设计模式，它实际上是一种编程习惯。一个工厂类根据传入的参数决定创建出哪一种产品类的实例。
  - 工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使用一个类的实例来创建另一个类的实例。
  - 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

#### 区别

- 目的不同：
  - 建造者模式主要用于创建复杂对象，强调的是一步步构造一个复杂对象，可以用不同的组合或顺序得到不同的结果。
  - 工厂模式主要用于创建类型族的对象，强调的是为客户端提供一个创建对象的接口，隐藏创建逻辑。
- 应用场景不同：
  - 建造者模式适用于那些产品对象的内部结构比较复杂，需要多步骤构建的场景。
  - 工厂模式适用于创建对象时，不希望客户端知道创建逻辑的场景。
- 实现复杂度不同：
  建造者模式的实现比工厂模式复杂，因为它通常需要多个步骤来创建一个对象，而工厂模式通常通过调用一个方法就可以直接创建对象。

总的来说，选择哪种模式取决于具体需求，如果需要更加精细和控制的对象创建过程，建造者模式可能是更好的选择。如果只是需要一个简单的接口来创建一系列相关或依赖的对象，工厂模式可能更适合。
