---
title: "建造模式"
date: 2022-03-13
weight: 4
categories: [设计模式]
author: "wangy325"
---

建造模式是一种创建型设计模式，它将一个复杂对象的构建与其表示分离。它允许你通过一步一步地构建对象来创建不同的表示。它通常用于创建复杂的对象。

建造模式有如下优点：

- 将复杂对象的构建与表示分离。
- 可以更容易地创建不同的表示。
- 可以方便地扩展新类型。

### 结构

建造模式包含以下角色：

- 抽象建造者（*Builder*）:  定义一个接口，指定构建复杂对象各个部分的步骤。
- 具体建造者（*ConcreteBuilder*）:  实现抽象建造者接口，具体实现构建复杂对象的步骤。
- 指挥者（*Director*）:  负责调用具体建造者的方法，构建复杂对象。
- 产品（*Product*）:  最终构建出来的复杂对象。

### UML简图

{{< mermaid >}}
classDiagram
direction LR
  class Builder {
    << interface >>
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class ConcreteBuilder1 {
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class ConcreteBuilder2 {
    +buildPartA()
    +buildPartB()
    +buildPartC()
    +getResult()
  }
  class Director {
    +construct()
  }
  class Product {
    +partA
    +partB
    +partC
  }

  Builder <|.. ConcreteBuilder1
  Builder <|.. ConcreteBuilder2
  Director --> Builder
  Director --> Product
  Product ..> ConcreteBuilder1
  Product ..> ConcreteBuilder2
{{< /mermaid >}}

### 示例代码

本示例中我们使用建造模式来创建一部车，一部车显然是一个“复杂”的对象，可以将它的创建分成不同的部分，比如座椅，引擎，行车电脑等等不同的模块。我们使用建造模式来创建一个“车”对象。

#### 建造者及其实现

建造者是一个接口，提供了创建对象的而步骤，具体的实现细节，可以由具体的子类控制。特别注意的是，`Builder`提供了两个重要的方法：

- `reset()`
- `getProduct()`

第一个方法用来重置构建器的这种参数，为下一次的构建做准备。

第二个方法顾名思义，用来获取产品。

{{< code items="Builder,CarBuilder" lang="java" >}}

#### 产品

产品，也就是我们最终要创建的对象，本例中，是一部车。

{{< code items="Product,Car" lang="java" >}}

在创建产品的过程中，很容易产生一些中间类型，本例中，“引擎”就是中间类型。此处代码做了极简处理。

{{< code items="Engine" lang="java" >}}

#### 指挥者

有了建造者和产品，需要控制产品的生成。那么就轮到`Director`出场了，它负责组装产品：

{{< code items="CarDirector" lang="java" >}}

#### 测试代码

{{< code items="TestBuilder" lang="java" >}}

### 建造模式和工厂模式的区别

> *Generated by chatgpt.*

**建造者模式**（*Builder Pattern*）和**工厂模式**（*Factory Pattern*，包括简单工厂模式、工厂方法模式和抽象工厂模式）都是用来创建对象的设计模式，但它们在意图、应用场景和实现方式上有所不同。

1. 建造者模式

    建造者模式主要用于创建一种**复杂的对象**，其产品通常需要多个部分按特定的过程组合而成。这种模式允许用户通过指定复杂对象的类型和内容就可以构建它们，*用户不需要知道内部的具体构建细节*。

    - 意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    - 应用场景：当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；当构造过程必须允许被构造的对象有不同的表示时。
    - 实现方式：通常由Director（指挥者）、Builder（建造者接口）、ConcreteBuilder（具体建造者）和Product（产品）组成。客户端创建Director对象，并用它所需要的Builder对象进行配置。Director决定如何以及何时让建造者产生部件，然后组合成产品返回。

2. 工厂模式

    工厂模式主要用于创建对象，特别是在创建某个类的对象时不希望指定确切的类。工厂模式通过调用一个工厂方法而不是直接调用构造函数来创建对象（可能是指定的接口或抽象类的具体实现）。

    - 意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
    - 应用场景：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定创建的对象时；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪个帮助子类是代理者这一信息局部化时。
    - 实现方式：可以分为三种：
    - 简单工厂模式：不属于GOF的23种设计模式，它实际上是一种编程习惯。一个工厂类根据传入的参数决定创建出哪一种产品类的实例。
    - 工厂方法模式：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使用一个类的实例来创建另一个类的实例。
    - 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

3. 总结

- 目的不同：
  - 建造者模式主要用于创建**复杂对象**，强调的是一步步构造一个复杂对象，可以用不同的组合或顺序得到不同的结果。
  - 工厂模式主要用于创建**类型族的对象**，强调的是为客户端提供一个创建对象的接口，隐藏创建逻辑。
- 应用场景不同：
  - 建造者模式适用于那些产品对象的内部结构比较复杂，需要多步骤构建的场景。
  - 工厂模式适用于创建对象时，不希望客户端知道创建逻辑的场景。
- 实现复杂度不同：
  建造者模式的实现比工厂模式复杂，因为它通常需要多个步骤来创建一个对象，而工厂模式通常通过调用一个方法就可以直接创建对象。

选择哪种模式取决于具体需求，如果需要更加精细和控制的对象创建过程，建造者模式可能是更好的选择。如果只是需要一个简单的接口来创建一系列相关或依赖的对象，工厂模式可能更适合。
